第一章

第一种算法： 二分查找： 100分一半 50&50 然后再分一半 25&25 再分一半 12.5&12.5
	步骤：log（2）100 =取整 7次
	普通： 查找100就是100次

大O表达法： 二分查找就是 O(log(2)100) 普通算法就是：O(100) 大O 就是这个O
	大O表示法表示的是操作数 说的是最差时间也就是最高次数才找到的次数
	O（log n） 对数次数
	O（n） 线性次数
	O（n × log n）快速排序次数
	O（n ^ 2）选择排序次数
	O（n！）旅行商问题次数

第二章

第一种数据结构：数组
第二种数据结构：链表：
	各有优点 根据情况选择需要哪一种存储方式
	数组： 告诉内存要多少位置 内存先给你预留出来相邻的位置 但是一旦满了就要重新分配
	链表： 告诉内存要多少位置 内存给你一大堆不相邻的空间链接在一起
	这就好比看电影 跟朋友想坐在一起就要用数组 如果不坐在一起就是链表
	问题： 数组的问题在于如果满了就要重新分配 很麻烦而且速度慢
		链表的问题在于不能一次性展示出来 如果要查找最后一个内存那就得遍历到最后
		因为链表中下一个内存的地址都存储在上一个内存中
	总结： 可以认为数组的读取快写入慢 链表的读取慢写入快
		读取： 数组地址都在一起 而且支持 随机访问和顺序访问 所以快
			链表地址都在上一个内存中 不支持随机访问 只支持顺序访问 所以慢
		中间插入： 数组需要把后面的元素都往后移所以慢 链表只要改一下上一个的地址所以快
		删除： 数组需要删掉之后把后面的元素都往前移动 链表只要修改一下上一个的地址
		数组还有一个缺点： 所有元素都必须是一样的(int, double, float...)		

			数组	链表
		读取    O(1)	O(n)
		插入	O(n)	O(1)
		删除	O(n)	O(1)
术语：位置从0开始 叫做“索引” 而不是位置
	每一个“索引”对应的值 叫一个元素

第二种算法：选择排序： 如果要为音乐播放次数排序 
	那么需要的步骤数就是 O(n*n) n次找到排名第一 
	好吧 我对了 实际是需要O(n + (n-1) + (n-2) ...1)也就是o(n * 2/1 * n)
	但是大O会省略1/2这样的常数 还不知道为啥 因此简单写作O（n^2）
	选择排序步骤上（O）算是慢的 找到最大的 排在第一位 剩下的找出最大的 排在第二位......

第三章

第三种算法： 递归：就是函数调用了函数自己 很多程序都用这种算法
		递归不一定性能更好 但是逻辑上更简单
		递归一旦没有设置什么时候结束 他就会没完没了 所以要设置一个跳出条件
		所以递归有两个条件 基线条件（base case）和递归条件（recursive case）
		基线条件： 函数不再调用自己 也就是什么时候跳出
		递归条件： 函数调用自己 也就是什么时候递归

数据结构 栈： 内存中的栈 也叫（call stack）
	栈不像数组和链表 只有两种操作： 压入（插入）和弹出（删除并读取）弹出就是拿起来第一张
	所有函数都是堆在栈中的 调用一次就压入一次
	函数调用另外一个函数 另外一个函数放在栈顶 return之后会被弹出 继续执行主函数
	在递归中是无限叠加在栈中的 如果每个栈位置都不释放掉（处理完）那占用内存是很可怕的
	解决办法1： 改写代码 用循环
	解决办法2： 使用尾递归

第四章

分而治之： （divide and conquer, D&C）一种著名的递归式解决方法
		这是一种遇到问题寻找算法的方法
		1/ 找出基线条件
		2/ 使用递归 不断将问题分解， 直到符合基线条件
		还是不太懂递归 休息一下马上回来
		休息了一会大致知道这个函数该怎么写了



				
